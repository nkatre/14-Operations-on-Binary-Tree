Question: ITERATIVE BFS and  ITERATIVE DFS Traversals of the tree 
Solution:
private static void bfs(BST bst) {      // BEST method for BFS Traversal
	// Similar to the method which prints nodes at every level of the BST
	Queue<Node> queue = new LinkedList<Node>();
	queue.add(bst.root);
	while(!queue.isEmpty()){
		Node n = queue.poll();
		System.out.print(n.data+" ");
		if(n.lchild!=null)
			queue.add(n.lchild);
		if(n.rchild!=null)
			queue.add(n.rchild);
	}
	System.out.println();
}
 
private static void dfs(BST bst) {     // BEST method for DFS Traversal
	Stack<Node> stack = new Stack<Node>();
	stack.push(bst.root);
	while(!stack.isEmpty()){
		Node n = stack.pop();
		System.out.print(n.data+" ");
		if(n.rchild!=null)//First insert the RCHILD into STACK, reason being, the tree will be printed from LEFT TO RIGHT
// However, even if LCHILD into STACK is inserted first, it is NOT worng, just that the tree will be printed from RIGHT TO LEFT
			stack.push(n.rchild);
		if(n.lchild!=null)  // Then insert LCHILD
			stack.push(n.lchild);
	}
	System.out.println();
}


Recursion: Always remember that recursion is calling the method again and again STACKWISE(It works similar to STACK operations)
Recursion works on Stack Frames. It works similar to STACK operations.

Question: RECURSIVE DFS Traversal of the tree 
Solution:

  // Global Variable for DFS
  	public static Stack<TreeNode> stack = new Stack<TreeNode>();
  	

  public static void recursiveDFS(TreeNode root) {   // Recursive DFS Program
	if(root == null)
		return;
	
	stack.push(root);
	System.out.print(root.data+" ");
    if(root.left!=null)
    	recursiveDFS(root.left);
    if(root.right!=null)
    	recursiveDFS(root.right);
    
    stack.pop();
}
  
  
 Question: Recursive BFS Tree Traversal
 Solution:
 Source: http://stackoverflow.com/questions/2549541/performing-breadth-first-search-recursively
 
(I'm assuming that this is just some kind of thought exercise, or even a trick homework/interview question, 
but I suppose I could imagine some bizarre scenario where you're not allowed any heap space for some reason
[some really bad custom memory manager? some bizarre runtime/OS issues?] while you still have access to the stack...)

Breadth-first traversal traditionally uses a queue, not a stack. The nature of a queue and a stack are pretty much opposite, 
so trying to use the call stack (which is a stack, hence the name) as the auxiliary storage (a queue) is pretty much doomed
to failure, unless you're doing something stupidly ridiculous with the call stack that you shouldn't be.

On the same token, the nature of any non-tail recursion you try to implement is essentially adding a stack to the algorithm.
This makes it no longer breadth first search on a binary tree, and thus the run-time and whatnot for traditional 
BFS no longer completely apply. Of course, you can always trivially turn any loop into a recursive call, but that's
not any sort of meaningful recursion.

However, there are ways, as demonstrated by others, to implement something that follows the semantics of BFS at some cost. 
If the cost of comparison is expensive but node traversal is cheap, then as @Simon Buchan did, you can simply run an 
iterative depth-first search, only processing the leaves. This would mean no growing queue stored in the heap, 
just a local depth variable, and stacks being built up over and over on the call stack as the tree is traversed 
over and over again. And as @Patrick noted, a binary tree backed by an array is typically stored in breadth-first 
traversal order anyway, so a breadth-first search on that would be trivial, also without needing an auxiliary queue.
  
  
  /**
         * Performs the operation first on the node itself, then on its left descendants, and
         * finally on its right descendants. In other words, a node is always visited before any of its
         * children.
         * (self -> go down left -> go down right)
         */
        public void preorderTraversal () {
                preorderTraversal(root);
                System.out.println();
        }
        
        private void preorderTraversal(Node node) {
                if (node == null) {
                        return;
                }
                
                System.out.print(node.key + " ");
                preorderTraversal(node.left);
                preorderTraversal(node.right);
        }
        
        /**
         * Sometimes recursive algorithms can be replaced with iterative algorithms that accomplish the same
         * task in a fundamentally different manner using different data structures.
         * Because recursion is so intrinsic to the definition of a preorder traversal, you may have trouble finding
         * an entirely different iterative algorithm to use in place of the recursive algorithm. 
         * In such a case, the best course of action is to understand what is happening in the recursion 
         * and try to emulate the process iteratively.
         */
        public void preorderNoRecursionTraveral() {
                if (root == null) {
                        return;
                }
                
                Stack<Node> stack = new Stack<BinarySearchTree.Node>();
                stack.push(root);
                while (!stack.isEmpty()) {
                        Node node = stack.pop();
                        System.out.print(node.key + " ");
                        
                        if(node.right != null) {
                                stack.push(node.right);
                        }
                        if(node.left != null) {
                                stack.push(node.left);
                        }
                }
                System.out.println();
        }
        
        
        /**
         * Performs the operation first on the node�s left descendants, then on the node
         * itself, and finally on its right descendants. 
         * In other words, the left subtree is visited first,
         * then the node itself, and then the node�s right subtree.
         * (go down left -> self -> go down right)
         */
        public void inorderTraversal() {
                inorderTraversal(root);
                System.out.println();
        }
        
        private void inorderTraversal(Node node) {
                if (node == null) {
                        return;
                }
                inorderTraversal(node.left);
                System.out.print(node.key + " ");
                inorderTraversal(node.right);
        }
        
        public void inorderTraversalNoRecursion() {
                if (root == null) {
                        return;
                }
                Stack<Node> s = new Stack<>();
                Node curr = this.root;
                s.push(curr);
                while (!s.isEmpty()) {
                        while (curr.left != null) {
                                s.push(curr.left);
                                curr = curr.left;
                        }
                        Node n = s.pop();
                        System.out.print(n.key + " ");
                        if (n.right != null) {
                                s.push(n.right);
                                curr = n.right;
                        }
                }
                
                System.out.println();
        }
        
        /**
         * 
         * Performs the operation first on the node�s left descendants, then on the node�s
         * right descendants, and finally on the node itself. In other words, a node is always visited
         * after all its children.
         * (go down left -> go down right -> self)
         */
        public void postorderTraversal() {
                postorderTraversal(root);
                System.out.println();
        }
        
        private void postorderTraversal(Node node) {
                if (node == null) {
                        return;
                }
                
                postorderTraversal(node.left);
                postorderTraversal(node.right);
                System.out.print(node.key + " ");
        }

        public void postorderTraversalNoRecursion() {
                if (root == null) {
                        return;
                }
                Stack<Node> stack = new Stack<BinarySearchTree.Node>();
                Node head = root;
                stack.push(head);

                while (!stack.isEmpty()) {
                        Node next = stack.peek();
                        if (next.right == head || next.left == head
                                        || (next.left == null && next.right == null)) {
                                stack.pop();
                                System.out.print(next.key + " ");
                                head = next;
                        } else {
                                if (next.right != null) {
                                        stack.push(next.right);
                                }
                                if (next.left != null) {
                                        stack.push(next.left);
                                }
                        }
                }
                System.out.println();
        }
