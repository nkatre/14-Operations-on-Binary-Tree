 
/* 
 Background: The below explanation is for the problem that I encountered while passing complex datatype such as array,
 between two PHP pages using POST method. The same explanation does apply to other complex datatypes as well, 
 such as in this case, a binary tree.

Source of Explanation: http://www.tuxradar.com/practicalphp/5/11/0
As arrays are complex data types, you cannot see their contents directly. 
If you try printing out the value of an array, you will see PHP just outputs "Array", 
which means that passing the value of an array through a link requires a lot of work. 
Luckily, PHP comes to the rescue with four functions
that do all the hard work for you: serialize(), unserialize(), urlencode(), and urldecode().

Serialize() converts an array, given as its only parameter, 
into a normal string that you can save in a file, pass in a URL, etc. 
Unserialize() is the opposite of serialize() - it takes a serialize()d string and converts it back to an array.

Urlencode() and urldecode() also work in tandem, and convert the string that is 
sent to them as their only parameter into a version that is safe to be passed across the web. 
All characters that aren't letters and numbers get converted into web-safe codes that can be 
converted back into the original text using urldecode().

Passing arrays across pages is best done using urlencode() and urldecode(), 
however you should consider using them both on any data you pass across the web, just
to make sure there are no incompatible characters in there. 

Solution for passing arrays through POST method between PHP pages: Solution: http://stackoverflow.com/questions/14071587/php-pass-array-through-post
Another solution using SESSION VARIABLE: http://stackoverflow.com/questions/10260720/pass-array-between-two-php-files
For Example: Using Session Variable
On the sending page: 
<?php
session_start();  // start a session
$column_headers = array("A","B","C","D");   // create array
$_SESSION['column_headers']=$column_headers; // store in session variable
?>

On the receiving page:
<?php
session_start(); // start session to retrieve the session variable
$column_headers=$_SESSION['column_headers']; // retrieve the session varaible
?>
*/
 
 /**Given a binary tree, serialize it into a string. In other words, generate a string
 representation of the tree such that you can uniquely construct the tree back from the string alone.

Assume the availability of a serialization function that takes the node of a tree and serializes it into a string. ie. Your job is to take care of the tree structure.
         * Method to serialize a binary tree.
         * for the input:
         * 
                                                         S-19
                         E-5                                                        X-23
        A-1                                R-18
                C-3                H-8
                                        M-13
                 
         * 
         * returns 19 5 1 NULL 3 NULL NULL 18 8 NULL 13 NULL NULL NULL 23 NULL NULL 
         * @param node
         * @return
         */
        public static String serialize(Node node) {
                StringBuilder builder = new StringBuilder();
                serialize(builder, node);
                return builder.toString();
        }
        
        /**
         * Makes a preorder traversal, keeping null nodes of the leaves
         * @param builder
         * @param node
         */
        private static void serialize(StringBuilder builder, Node node) {
                if (node == null) {
                        return;
                }
                
                builder.append(node.value);
                builder.append(" ");
                
                if (node.left != null) {
                        serialize(builder, node.left);
                }
                else {
                        builder.append("NULL ");
                }
                
                if (node.right != null) {
                        serialize(builder, node.right);
                }
                else {
                        builder.append("NULL ");
                }
        }
        
        /**
         * Receives a string and parse it to a binary tree
         * @param str
         * @return
         */
        public static Node deserialize(String str) {
                if (str == null || str.isEmpty()) {
                        return null;
                }
                String[] data = str.split(" ");
                Queue<Node> q = new Queue<BinarySearchTree.Node>();
                BinarySearchTree b = new BinarySearchTree();
                
                int n = 0;
                for(String s : data) {
                        n++;
                        if (s.equals("NULL")) {
                                q.enqueue(null);
                        } else {
                                Node node = b.new Node(s, Integer.parseInt(s), n);
                                q.enqueue(node);
                        }
                }
                Node root = deserialize(q, q.dequeue());
                return root;
        }

        /**
         * 
         * @param q
         * @param node
         * @return
         */
        private static Node deserialize(Queue<Node> q, Node node) {
                if (node == null) {
                        return null;
                }
                node.left = deserialize(q, q.dequeue());
                node.right = deserialize(q, q.dequeue());
                
                return node;
        }
       
       
       
       
       
       
       // PLEASE DONT SEE THE MAIN, ITS NOT REQUIRED. THE MAIN CAN HAVE NORMAL TREE WITH LEFT AND RIGHT
       // IT DOESNT NEED TO BE LIKE THE WAY ITS MENTIONED BELOW
       
       
       
        
        public static void main(String[] args) {
                /*
                                                         S-19
                         E-5                                                        X-23
        A-1                                R-18
                C-3                H-8
                                        M-13
                 */
                
                
                BinarySearchTree BST = new BinarySearchTree();
                BST.put("S", 19);
                BST.put("E", 5);
                BST.put("X", 23);
                BST.put("A", 1);
                BST.put("R", 18);
                BST.put("C", 3);
                BST.put("H", 8);
                BST.put("M", 13);
//                System.out.println(BST.height());
//                BST.preorderTraversal();
//                BST.preorderNoRecursionTraveral();
//                BST.inorderTraversal();
                BST.inorderTraversalNoRecursion();
//                BST.postorderTraversal();
//                BST.postorderTraversalNoRecursion();
                
                /*String str = BinarySearchTree.serialize(BST.root);
                System.out.println(str);
                BinarySearchTree.deserialize(str);*/
                
//                BinarySearchTree balanced = new BinarySearchTree();
//                balanced.put("S", 19);
//                balanced.put("E", 5);
//                balanced.put("X", 23);
//                balanced.put("A", 1);
//                System.out.println(BST.isBalanced());
//                System.out.println(balanced.isBalanced());
        }
