/*
Diameter of a tree: The diameter of a tree is defined as the number of nodes between the extreme left node
and the extreme right node of a tree
*/

public int diameter(){
		return diameter(root);
	}
	public int diameter(Node root){
		if(root==null)
			return 0;
		
		int lheight=height(root.lchild);
		int rheight=height(root.rchild);
		
		int ldiameter=diameter(root.lchild);
		int rdiameter=diameter(root.rchild);
		
		return Math.max(lheight+1+rheight, Math.max(ldiameter, rdiameter));
		
	}
	
	
	public int height(){
		return height(root);
	}
	
	public static int height(Node n){
	if(n==null)
	return 0;
	return(1+Math.max(height(n.lchild), height(n.rchild)));
}
	

	Time Complexity: O(2n)


For calculating height we can also use:

	
	public int height(Node root){
		if(root==null)
			return 0;
		int ltree= height(root.lchild);
		int rtree= height(root.rchild);
		
		return Math.max(ltree+1,rtree+1);
	}

/*Optimized implementation: The above implementation can be optimized by calculating 
the height in the same recursion rather than calling a height() separately.
This optimization reduces time complexity to O(n). */

/* Time Complexity of this solution is: O(n) */

/*The second parameter is to store the height of tree.
   Initially, we need to pass a pointer to a location with value
   as 0. So, function should be used as follows:
 
   int height = 0;
   struct node *root = SomeFunctionToMakeTree();
   int diameter = diameterOpt(root, &height); */
   
   
   
int diameterOpt(struct node *root, int* height)
{
  /* lh --> Height of left subtree
      rh --> Height of right subtree */
  int lh = 0, rh = 0;
  
  /* ldiameter  --> diameter of left subtree
      rdiameter  --> Diameter of right subtree */
  int ldiameter = 0, rdiameter = 0;
  
  if(root == NULL)
  {
    *height = 0;
     return 0; /* diameter is also 0 */
  }
  
  /* Get the heights of left and right subtrees in lh and rh
    And store the returned values in ldiameter and ldiameter */
    
    
  ldiameter = diameterOpt(root->left, &lh);
  rdiameter = diameterOpt(root->right, &rh);
  
  
  /* Height of current node is max of heights of left and
     right subtrees plus 1 */
     
  *height = max(lh, rh) + 1;
  
  return max(lh + rh + 1, max(ldiameter, rdiameter));
  
}
